"""
Supplementary methods for the Reader class and others
These methods don't belong to any specific class operation and may be used across the entire project
@author: daniel kuknyo
"""
from exceptions import *


def start_sim(roads: list, vehicle_mtx: dict, offset: tuple, steps_per_update: int) -> None:
    """
    A wrapper class to start the simulation based on parameters generated by a reader object.
    :param roads: matrix connecting each road as per coordinates [(A, B), (B, C)] where Node N --> (x, y) coordinates of floats
    :param vehicle_mtx: dict that controls the setting of vehicles: {vehicle_rate: :.2f, 'vehicles': [nr_of_vehicles, {'path': [index(A), index(B), index(C)]}]}
    :param offset: pygame offset parameter for the city in the window
    :param steps_per_update: number of steps passing between each frame of the simulation (should be turned off for learning phase)
    :return:
    """
    # Necessary imports
    from trafficSimulator.simulation import Simulation
    from trafficSimulator.window import Window
    # Set up everything
    sim = Simulation()
    sim.create_roads(roads)
    sim.create_gen(vehicle_mtx)
    win = Window(sim)
    win.offset = offset  # (x, y) tuple
    win.run(steps_per_update)


def letter_to_number(letter: str) -> int:
    """
    Converts a letter to a number in GeoGebra representation
    GeoGebra names points as [A, B, C, ..., Z, A1, B1, C1, ..., Z1, A2, B2, C2, ...]
    :param letter: the The letter to be converted to a number
    :return: the numeric representation of the letter starting with 0
    """
    if len(letter) == 1:  # A, B, C
        return ord(letter) - ord('A')
    else:  # A1, B1, C1
        return int(letter[1:]) * 26 + ord(letter[0]) - ord('A')


def l2n(x: str) -> int:
    """
    This is an alias for letter_to_numer
    :param x: String representing a single character starting from 'A' = 0
    :return: integer representing a single character
    """
    return letter_to_number(x)


def letter_to_number_lst(lst: list) -> list:
    """
    Converts a list of letters to numbers
    :param lst: list full of capital letters that refer to nodes e.g.: ['A', 'B', 'C', 'D', 'E', 'F']
    :return: list of converted numbers to letters e.g.: [0, 1, 2, 3, 4, 5]
    """
    return list(map(letter_to_number, lst))  # Do conversion and return


def drop_empty_keys(dct: dict) -> dict:
    """
    Drops the empty keys from a given dict and returns the dict itself
    :param dct: The dict to drop from
    :return: dict: The dict with the empty keys removed
    """
    for v in list(dct.keys()):
        if len(dct[v]) == 0:
            dct.pop(v, None)
    return dct


def find_key_to_value(dct: dict, val):
    """
    Returns the key that belongs to a given value in a dictionary
    Note: value van be of any type. Return type is of same type that the keys are stored as
    :param dct: The dictionary to be traversed
    :param val: The value to be looked for
    :return: The key belonging to the value
    """
    return list(dct.keys())[list(dct.values()).index(val)]


def calc_intermediate_point(p1: tuple, p2: tuple, r: float) -> tuple:
    """
    Calculates the intermediate point on the segment between two given points of (x,y) tuples
    E.g. A ---> C ---> B for r=2, C is 1/2 of the way between A and B. For r=3 C is 1/3 of the way between A and B
    :param p1: (x, y) tuple that represents point A
    :param p2: (x, y) tuple that represents point B
    :param r: ratio that defines where on the segment is point C
    :return: (x, y) tuple that defines point C
    """
    if r <= 0 or 1 <= r:  # Test for illegal midpoint values
        raise IllegalMidPointError("Midpoint is out of the 0...1 range: {:.2f}".format(r))
    # (x1 + k / n * (x2 - x1), y1 + k / n * (y2 - y1))
    x1, y1 = p1
    x2, y2 = p2
    return x1 + r * (x2 - x1), y1 + r * (y2 - y1)
