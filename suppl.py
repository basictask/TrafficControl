"""
Supplementary methods for the Reader class and others
These methods don't belong to any specific class operation and may be used across the entire project
@author: daniel kuknyo
"""
from exceptions import *
from trafficSimulator.window import Window
from trafficSimulator.simulation import Simulation
import pandas as pd
import math

# This is a constant to easily set the junction types' representations
JUNCTION_CODES = {'righthand': 1, 'roundabout': 2, 'trafficlight': 3}


def start_sim(roads: list, vehicle_mtx: dict, offset: tuple, steps_per_update: int, n_steps: int, show_win: bool, signals: list = None) -> None:
    """
    A wrapper function to start the simulation based on parameters generated by a reader object.
    :param roads: Matrix connecting each road as per coordinates [(A, B), (B, C)] where Node N --> (x, y) coordinates of floats
    :param vehicle_mtx: Dict that controls the setting of vehicles: {vehicle_rate: :.2f, 'vehicles': [nr_of_vehicles, {'path': [index(A), index(B), index(C)]}]}
    :param offset: Pygame offset parameter for the city in the window
    :param steps_per_update: Number of steps passing between each frame of the simulation (should be turned off for learning phase)
    :param n_steps: Number of steps to take for each simulation (Only if show_win is set to True)
    :param show_win: Set to True if you want to show the simulation window
    :param signals: List of traffic lights to create
    :return: None
    """
    # Set up everything
    sim = Simulation()
    sim.create_roads(roads)
    sim.create_gen(vehicle_mtx)

    # Create the traffic signals if the value was passed
    if signals is not None and len(signals) > 0:
        for signal_junction in signals:
            sim.create_signal(signal_junction)

    # If True the window will be displayed on the screen ==> For visualization
    if show_win:
        win = Window(sim, steps_per_update, n_steps)
        win.offset = offset  # (x, y) tuple
        win.run()
    # Only simulate, don't display. ==> For the RL environment only
    else:
        sim.run(n_steps)


def letter_to_number(letter: str) -> int:
    """
    Converts a letter to a number in GeoGebra representation
    GeoGebra names points as [A, B, C, ..., Z, A1, B1, C1, ..., Z1, A2, B2, C2, ...]
    :param letter: The The letter to be converted to a number
    :return: The numeric representation of the letter starting with 0
    """
    if len(letter) == 1:  # A, B, C
        return ord(letter) - ord('A')
    else:  # A1, B1, C1
        return int(letter[1:]) * 26 + ord(letter[0]) - ord('A')


def l2n(letter: str) -> int:
    """
    This is an alias for letter_to_numer
    :param letter: String representing a single character starting from 'A' = 0
    :return: Integer representing a single character
    """
    return letter_to_number(letter)


def letter_to_number_lst(lst: list) -> list:
    """
    Converts a list of letters to numbers
    :param lst: List full of capital letters that refer to nodes e.g.: ['A', 'B', 'C', 'D', 'E', 'F']
    :return: List of converted numbers to letters e.g.: [0, 1, 2, 3, 4, 5]
    """
    return list(map(letter_to_number, lst))  # Do conversion and return


def number_to_letter(num: int) -> str:
    """
    Converts a letter back to a number
    :param num: The number to be converted
    :return: The alphabetical representation of the number where 0 --> A, 1 --> B ...
    """
    if num < 26:
        return chr(num + 65)
    else:
        return chr(num % 26 + 65) + str(num // 26)


def n2l(num: int) -> str:
    """
    This is an alias for number_to_letter
    :param num: Numerical form of the letter
    :return: Alphabetical representation of the letter
    """
    return number_to_letter(num)


def pretty_matrix(matrix: pd.DataFrame) -> pd.DataFrame:
    """
    Converts the representational matrix into a prettier form
    :param matrix: The n*n representational matrix
    :return: The representational matrix where all the point identification numbers have been converted to letters
    """
    result = matrix.copy()
    result.index = [n2l(x) for x in matrix.index]
    result.columns = [n2l(x) for x in matrix.columns]
    return result


def drop_empty_keys(dct: dict) -> dict:
    """
    Drops the empty keys from a given dict and returns the dict itself
    :param dct: The dict to drop from
    :return: dict: The dict with the empty keys removed
    """
    for v in list(dct.keys()):
        if len(dct[v]) == 0:
            dct.pop(v, None)
    return dct


def find_key_to_value(dct: dict, val):
    """
    Returns the key that belongs to a given value in a dictionary
    Note: value van be of any type. Return type is of same type that the keys are stored as
    :param dct: The dictionary to be traversed
    :param val: The value to be looked for
    :return: The key belonging to the value
    """
    try:
        return list(dct.keys())[list(dct.values()).index(val)]
    except ValueError:
        raise NotStoredError('Dictionary doesn\'t contain value: {}'.format(val))


def calc_intermediate_point(start: tuple, end: tuple, r: float) -> tuple:
    """
    Calculates the intermediate point on the segment between two given points of (x,y) tuples
    E.g. A ---> C ---> B for r=2, C is 1/2 of the way between A and B. For r=3 C is 1/3 of the way between A and B
    :param start: (x, y) tuple that represents point A
    :param end: (x, y) tuple that represents point B
    :param r: Ratio that defines where on the segment is point C
    :return: (x, y) tuple that defines point C
    """
    if r <= 0 or 1 <= r:  # Test for illegal midpoint values
        raise IllegalMidPointError("Midpoint is out of the 0...1 range: {:.2f}".format(r))
    x1, y1 = start
    x2, y2 = end
    return x1 + r * (x2 - x1), y1 + r * (y2 - y1)


def find_angle(start: tuple, end: tuple, absolute: bool = True) -> float:
    """
    Find the angle between the x-axis and a line defined by two points rounded to 4 decimals.
    :param start: (x, y) tuple that represents point A
    :param end: (x, y) tuple that represents point B
    :param absolute: True if the method should return the angle between the entire x-axis. If False it will return degrees with the positive x-axis
    :return: The angle between the x-axis and the line defined by {p1, p2} in degrees
    Note: The angle will always be in the 0...90 range if absolute is set to true. It will be in the 0...360 range when unique is set to False.
    """
    angle_rad = math.atan2(start[1] - end[1], start[0] - end[0])
    angle_deg = math.degrees(angle_rad)
    angle_deg = round(angle_deg, 4)
    if absolute:
        if angle_deg < 0:
            angle_deg += 360
        if angle_deg > 90:
            angle_deg = 180 - angle_deg
        return abs(angle_deg)
    return angle_deg


def count_incoming_lanes(segments: list, points: dict, node: int, unique: bool) -> int:
    """
    Counts the number of lanes incoming given a certain node
    The number of incoming lanes is the number of segments that have a given node as the ending point
    :param segments: Segments DataFrame that defines the graph connections by ID
    :param points: Dictionary that defines the index:location mapping -> int:(x, y)
    :param node: The junction to count at (int)
    :param unique: If unique is set to True multiple lanes of one road won't get counted as a separate entity
    :return: Number of lanes incoming towards node as integer (unique or not)
    """
    angles = []
    for start, end in segments:
        if end == node:
            angles.append(find_angle(points[start], points[end], absolute=False))
    if unique:
        return len(set(angles))
    else:
        return len(angles)
