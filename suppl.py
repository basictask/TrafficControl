"""
Supplementary methods for the Reader class and others
These methods don't belong to any specific class operation and may be used across the entire project
@author: daniel kuknyo
"""
from exceptions import *
from trafficSimulator.window import Window
from trafficSimulator.simulation import Simulation
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import torch
import math
import os

# This is a constant to easily set the junction types' representations
JUNCTION_CODES = {'righthand': 1, 'roundabout': 2, 'trafficlight': 3}
JUNCTION_TYPES = {v: k for k, v in JUNCTION_CODES.items()}  # Inverse of the JUNCTION_CODES dict

# Actions are defined here in a dict as a constant
# ACTIONS = {0: 'add_lane', 1: 'remove_lane', 2: 'add_road', 3: 'remove_road', 4: 'add_righthand', 5: 'add_roundabout', 6: 'add_trafficlight'}
ACTIONS = {0: 'add_lane', 1: 'remove_lane', 2: 'add_righthand', 3: 'add_roundabout', 4: 'add_trafficlight'}
ACTION_NAMES = {v: k for k, v in ACTIONS.items()}  # Inverse of the ACTIONS dict

# Logs folder
IMAGES_PATH = './logs/images'
HISTORY_PATH = './logs/history'


def start_sim(roads: list, vehicle_mtx: dict, offset: tuple, steps_per_update: int, n_steps: int, show_win: bool, signals: list = None) -> (float, float):
    """
    A wrapper function to start the simulation based on parameters generated by a reader object.
    :param roads: Matrix connecting each road as per coordinates [(A, B), (B, C)] where Node N --> (x, y) coordinates of floats
    :param vehicle_mtx: Dict that controls the setting of vehicles: {vehicle_rate: :.2f, 'vehicles': [nr_of_vehicles, {'path': [index(A), index(B), index(C)]}]}
    :param offset: Pygame offset parameter for the city in the window
    :param steps_per_update: Number of steps passing between each frame of the simulation (should be turned off for learning phase)
    :param n_steps: Number of steps to take for each simulation (Only if show_win is set to True)
    :param show_win: Set to True if you want to show the simulation window
    :param signals: List of traffic lights to create
    :return: None
    """
    # Set up the simulation using the matrices from the Reader
    sim = Simulation()
    sim.create_roads(roads)
    sim.create_gen(vehicle_mtx)

    # Create the traffic signals if the value was passed
    if signals is not None and len(signals) > 0:
        for signal_junction in signals:
            sim.create_signal(signal_junction)

    # If True the window will be displayed on the screen ==> For visualization
    if show_win:
        win = Window(sim, steps_per_update, n_steps)
        win.offset = offset  # (x, y) tuple
        win.run()
        return 0, 0

    # Only simulate, don't display. ==> For the RL environment only
    else:
        total_n_vehicles, total_vehicles_distance = sim.run(n_steps)
        return total_n_vehicles, total_vehicles_distance


def letter_to_number(letter: str) -> int:
    """
    Converts a letter to a number in GeoGebra representation
    GeoGebra names points as [A, B, C, ..., Z, A1, B1, C1, ..., Z1, A2, B2, C2, ...]
    :param letter: The The letter to be converted to a number
    :return: The numeric representation of the letter starting with 0
    """
    if len(letter) == 1:  # A, B, C
        return ord(letter) - ord('A')
    else:  # A1, B1, C1
        return int(letter[1:]) * 26 + ord(letter[0]) - ord('A')


def l2n(letter: str) -> int:
    """
    This is an alias for letter_to_numer
    :param letter: String representing a single character starting from 'A' = 0
    :return: Integer representing a single character
    """
    return letter_to_number(letter)


def letter_to_number_lst(lst: list) -> list:
    """
    Converts a list of letters to numbers
    :param lst: List full of capital letters that refer to nodes e.g.: ['A', 'B', 'C', 'D', 'E', 'F']
    :return: List of converted numbers to letters e.g.: [0, 1, 2, 3, 4, 5]
    """
    return list(map(letter_to_number, lst))  # Do conversion and return


def number_to_letter(num: int) -> str:
    """
    Converts a letter back to a number
    :param num: The number to be converted
    :return: The alphabetical representation of the number where 0 --> A, 1 --> B ...
    """
    if num < 26:
        return chr(num + 65)
    else:
        return chr(num % 26 + 65) + str(num // 26)


def n2l(num: int) -> str:
    """
    This is an alias for number_to_letter
    :param num: Numerical form of the letter
    :return: Alphabetical representation of the letter
    """
    return number_to_letter(num)


def pretty_matrix(matrix: pd.DataFrame) -> pd.DataFrame:
    """
    Converts the representational matrix into a prettier form
    :param matrix: The n*n representational matrix
    :return: The representational matrix where all the point identification numbers have been converted to letters
    """
    result = matrix.copy()
    result.index = [n2l(x) for x in matrix.index]
    result.columns = [n2l(x) for x in matrix.columns]
    return result


def pretty_segments(df_segments: pd.DataFrame) -> pd.DataFrame:
    """
    Pretty print for df_segments where the numbers get converted to letters for debugging purposes
    :param df_segments: Segment matrix generated by the assembler
    :return: Pandas DataFrame of the same dimension
    """
    result = df_segments.copy()
    result['Letter'] = [[] for _ in result['Definition']]
    for ind in result.index:
        for x in result.loc[ind, 'Definition']:
            result.loc[ind, 'Letter'].append(n2l(x))
    result.drop('Definition', axis=1, inplace=True)
    result.sort_values(by='Letter', inplace=True)
    return result


def drop_empty_keys(dct: dict) -> dict:
    """
    Drops the empty keys from a given dict and returns the dict itself
    :param dct: The dict to drop from
    :return: dict: The dict with the empty keys removed
    """
    for v in list(dct.keys()):
        if len(dct[v]) == 0:
            dct.pop(v, None)
    return dct


def find_key_to_value(dct: dict, val):
    """
    Returns the key that belongs to a given value in a dictionary
    Note: value van be of any type. Return type is of same type that the keys are stored as
    :param dct: The dictionary to be traversed
    :param val: The value to be looked for
    :return: The key belonging to the value
    """
    try:
        return list(dct.keys())[list(dct.values()).index(val)]
    except ValueError:
        raise NotStoredError('Dictionary doesn\'t contain value: {}'.format(val))


def calc_intermediate_point(start: tuple, end: tuple, r: float) -> tuple:
    """
    Calculates the intermediate point on the segment between two given points of (x,y) tuples
    E.g. A ---> C ---> B for r=2, C is 1/2 of the way between A and B. For r=3 C is 1/3 of the way between A and B
    :param start: (x, y) tuple that represents point A
    :param end: (x, y) tuple that represents point B
    :param r: Ratio that defines where on the segment is point C
    :return: (x, y) tuple that defines point C
    """
    if r <= 0 or 1 <= r:  # Test for illegal midpoint values
        raise IllegalMidPointError("Midpoint is out of the 0...1 range: {:.2f}".format(r))
    x1, y1 = start
    x2, y2 = end
    return round(x1 + r * (x2 - x1), 4), round(y1 + r * (y2 - y1), 4)


def find_angle(start: tuple, end: tuple, absolute: bool = True) -> float:
    """
    Find the angle between the x-axis and a line defined by two points rounded to 4 decimals.
    :param start: (x, y) tuple that represents point A
    :param end: (x, y) tuple that represents point B
    :param absolute: True if the method should return the angle between the entire x-axis. If False it will return degrees with the positive x-axis
    :return: The angle between the x-axis and the line defined by {p1, p2} in degrees
    Note: The angle will always be in the 0...90 range if absolute is set to true. It will be in the 0...360 range when unique is set to False.
    """
    angle_rad = math.atan2(start[1] - end[1], start[0] - end[0])  # Angle in radians
    angle_deg = math.degrees(angle_rad)  # Angle in degrees
    if absolute:
        if angle_deg < 0:
            angle_deg += 360
        if angle_deg > 90:
            angle_deg = 180 - angle_deg
        return round(abs(angle_deg), 3)
    return round(angle_deg, 3)


def count_incoming_lanes(matrix: pd.DataFrame, node: int, unique=True) -> int:
    """
    Counts the number of lanes incoming given a certain node
    The number of incoming lanes is the number of segments that have a given node as the ending point
    :param matrix: The n*n representational matrix
    :param node: The junction to count at (int)
    :param unique: True: number of incoming roads, False: number of incoming lanes
    :return: Number of lanes incoming towards node as integer (unique or not)
    """
    if unique:
        ds = pd.Series(matrix.loc[:, node].drop(node))
        return ds[ds > 0].count()
    else:
        return matrix.lox[:, node].drop(node).sum()


def find_closest_point_circle(point: tuple, center: tuple, r: float) -> tuple:
    """
    Finds the point on the perimeter of a circle that lies closest to a given point
    :param point: (x, y) tuple defining the starting point
    :param center: (x, y) tuple defining the center of the point
    :param r: float value reoresenting the radius of the circle
    :return: (x, y) point that lies on the perimeter of the circle that is the closest to the point
    """
    x1, y1 = center
    x2, y2 = point
    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)  # Distance between the point and center
    if d >= r:
        v = (x2 - x1, y2 - y1)
        nv = (v[0] / d, v[1] / d)  # Normalize the vector
        cv = (r * nv[0], r * nv[1])  # Calculate the vector from the center of the circle to the closest point
        closest_point = (x1 + cv[0], y1 + cv[1])  # Calculate the coordinates of the closest point on the circle
        return round(closest_point[0], 4), round(closest_point[1], 4)
    return point  # If the distance is less than the radius, the closest point is the given point itself


def check_connection_exists(df_segments: pd.DataFrame, connection: tuple) -> bool:
    """
    Checks if a connection is present in the df_segments variable
    :param df_segments: df_segments created in the Assembler
    :param connection: (x, y) tuple of indices that is examined
    :return: True: connection is present, False: connection is not present
    """
    # Finds all the indices where the connection is present and returns if the length is larger than 0
    return len(df_segments.loc[df_segments['Definition'] == connection, :].index) > 0


def euclidean_distance(p1: tuple, p2: tuple) -> float:
    """
    Euclidean distance function between two points
    :param p1: (x, y) tuple of the first point
    :param p2: (x, y) tuple of the second point
    :return: float value that represents the distance
    """
    x1, y1 = p1
    x2, y2 = p2
    distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
    return distance


def check_all_coords_valid(points: dict, max_lanes: int, roundabout_radius: float) -> bool:
    """
    Checks if all points are far apart enough in order to add roundabouts around the nodes
    :param points: Dictionary of points {index: (x, y), index: (x, y)...}
    :param max_lanes: Number of maximum lanes in one direction (set by user in reader)
    :param roundabout_radius: Radius of roundabouts (defined in the Reader class, generally no point in modifying it).
    :return: True: all coordinates are far apart enough, False: some coordinates lie too close to eachother
    """
    ds = pd.Series(points)
    i = 0
    while i < len(ds) - 1:
        j = i + 1
        while j < len(ds):
            dist = euclidean_distance(ds.iloc[i], ds.iloc[j])
            if dist < 2 * max_lanes * roundabout_radius + 2:  # Two roundabouts times max. lanes next to eachother Plus a margin for error
                raise IllegalNodeConfigurationError('Some nodes are placed too close to eachother: {}, {}'.format(ds.iloc[i].index, ds.iloc[j].index))
            j += 1
        i += 1
    return True


def check_valid_df_segments(df_segments: pd.DataFrame, points: dict) -> bool:
    """
    Checks if all point IDs are valid in the df_segments DataFrame (usually before calling redo_config)
    :param df_segments: Pandas DataFrame that defines the roads
    :param points: Dictionary containing the location of the points
    :return: True: valid segments, False: invalid segments
    """
    for start, end in df_segments['Definition']:
        if start not in points.keys() or end not in points.keys() or start < 0 or end < 0:
            return False
    return True


def check_entry_points_valid(points: dict, entry_points: list) -> bool:
    """
    Checks if all entry points are valid for a point configuration
    :param points: Dictionary of points {index: (x, y), index: (x, y)...}
    :param entry_points: List of entry points e.g. ['A', 'C', 'D', 'E', ...]
    :return: True: all entry points are present in the point, False: some entry points were given that are not present in the points
    """
    for p in entry_points:
        if p not in points.keys():
            raise IllegalEntryPointError(f'Entry point not present in graph: {number_to_letter(p)}')
    return True


def check_all_attributes_initialized(obj: object) -> None:
    """
    Checks if all public properties of _attr_name_ have initialized values
    :param obj: Any type of object
    :return: Throws an exception if any Nonetype attribute value is found
    """
    for attr_name in dir(obj):
        if attr_name[:1] != '_' and attr_name[-1:] != '_' and getattr(obj, attr_name) is None:
            raise NoneTypeAttributeError(f'Error: some attributes of {type(obj).__name__} are set to None: {attr_name}')


def apply_decay(eps: float, eps_end: float, eps_decay: float):
    """
    Applies epsilon decay to epsilon then returns the new value
    :param eps: Epsilon [exploration probability]
    :param eps_end: Minimum value of epsilon
    :param eps_decay: Decay factor
    :return:
    """
    if eps > eps_end:
        eps *= eps_decay
    return eps


def choose_random_action(start: int, end: int, state: pd.DataFrame, action_size: int, state_high: pd.DataFrame, trafficlight_inbound: list) -> int:
    """
    Chooses a valid random action depending on the state
    :param start: Index of the starting node
    :param end: Index of the anding node
    :param state: State-definition matrix
    :param action_size: Number of possible action (int)
    :param state_high: Pandas DataFrame containing the highest values for all states
    :param trafficlight_inbound: List of allowed incoming roads in case of trafficlight intersections
    :return: Integer representation of valid action
    """
    current_state_start_end = state.loc[start, end]
    current_state_end_end = state.loc[end, end]
    current_junction = JUNCTION_TYPES[current_state_end_end]
    all_actions = list(range(action_size))

    if start != end and current_state_start_end == state_high.loc[start, end]:  # Maximum number of lanes reached
        all_actions.remove(ACTION_NAMES['add_lane'])

    elif start != end and current_state_start_end == 0:
        all_actions.remove(ACTION_NAMES['remove_lane'])

    if start == end:
        all_actions.remove(ACTION_NAMES['add_lane'])
        all_actions.remove(ACTION_NAMES['remove_lane'])

    if current_junction == 'righthand':
        all_actions.remove(ACTION_NAMES['add_righthand'])

    elif current_junction == 'roundabout':
        all_actions.remove(ACTION_NAMES['add_roundabout'])

    elif current_junction == 'trafficlight':
        all_actions.remove(ACTION_NAMES['add_trafficlight'])

    if ACTION_NAMES['add_trafficlight'] in all_actions and not count_incoming_lanes(state, end) in trafficlight_inbound:
        all_actions.remove(ACTION_NAMES['add_trafficlight'])

    return np.random.choice(all_actions)


def get_batch_graph_features(state: torch.tensor, indexer: torch.tensor):
    """
    Returns a batch of node features for the training of the graph convolutional neural network
    :param state: State-definition tensor of shape batch_size * n_nodes * n_nodes
    :param indexer: Indexer the given columns of the matrix. Either start or end node
    :return: Torch tensor of shape batch_size * n_nodes
    """
    features = torch.zeros((0, state.shape[-1]))
    for i in range(len(indexer)):
        features = torch.vstack((features, state[i][indexer[i]]))
    return features


def get_batch_embeddings(embeddings: torch.tensor, indexer: torch.tensor):
    """
    Finds the embeddings belonging to the nodes that are given by the indexer
    :param embeddings: Torch tensoor of n_nodes * embedding_size
    :param indexer: Torch tensor of size 1 * batch_size
    :return: Torch tensor of batch_size * embedding_size
    """
    batch_embeddings = torch.zeros((0, embeddings.shape[1]))
    for i in range(len(indexer)):
        batch_embeddings = torch.vstack((batch_embeddings, embeddings[indexer[i], :]))
    return batch_embeddings


def save_fig(fig_id: str, tight_layout: bool = True, fig_extension: str = "png", resolution: int = 200):
    """
    Saves a figure to the defined path
    :param fig_id: Name of the figure without extension
    :param tight_layout: If matplotlib tight layout should be turned on
    :param fig_extension: Extension of the figure
    :param resolution:
    :return:
    """
    path = os.path.join(IMAGES_PATH, fig_id + '.' + fig_extension)
    print('Saving figure', fig_id)
    if tight_layout:
        plt.tight_layout()
    plt.savefig(path, format=fig_extension, dpi=resolution)
